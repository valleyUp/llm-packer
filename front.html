<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Model Downloader</title>
    <link rel="stylesheet" href="https://unpkg.com/element-plus@2.3.14/dist/index.css">
    <script src="https://unpkg.com/vue@3.3.4/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus@2.3.14/dist/index.full.js"></script>
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.1);
            padding: 28px;
            margin-top: 20px;
        }
        .title {
            text-align: center;
            margin-bottom: 28px;
            color: #2c3e50;
            font-size: 2rem;
            font-weight: 600;
        }
        .form-item {
            margin-bottom: 22px;
        }
        .model-size-info {
            font-size: 0.9rem;
            color: #555;
            margin-top: 5px;
        }
        .button-group {
            display: flex;
            gap: 12px;
            justify-content: flex-start;
            margin-top: 25px;
            flex-wrap: wrap;
        }
        .task-controls button {
            margin-right: 10px;
        }
        .progress-container {
            margin-top: 25px;
        }
        .progress-text {
            text-align: center;
            font-size: 0.9rem;
            color: #555;
            margin-top: 6px;
        }
        .result-message {
            margin-top: 25px;
            padding: 14px;
            border-radius: 6px;
            font-size: 0.9rem;
            border: 1px solid;
            word-break: break-word;
        }
        .result-success {
            background-color: #e1f3d8;
            color: #67c23a;
            border-color: #c3e6cb;
        }
        .result-error {
            background-color: #fde2e2;
            color: #f56c6c;
            border-color: #f5c6cb;
        }
        .section-title {
            font-size: 1.25rem;
            color: #2c3e50;
            margin-bottom: 15px;
            margin-top: 30px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .el-tabs__nav-wrap::after {
            background-color: transparent;
        }
        .debug-info {
            font-size: 0.8rem;
            color: #999;
            margin-top: 20px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 4px;
            display: none;
        }
        .archive-section {
            margin-top: 20px;
            padding: 16px;
            border: 1px solid #eaeaea;
            border-radius: 6px;
            background-color: #fcfcfc;
        }
        .filter-info {
            font-size: 0.8rem;
            color: #606266;
            margin-top: 4px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="app" class="container">
        <h1 class="title">Advanced Model Downloader</h1>
        <div v-if="appLoaded">
            <el-tabs v-model="activeTab" tab-position="top">
                <el-tab-pane label="Model Download" name="download">
                    <el-form :model="form" label-width="180px">
                        <el-form-item label="Model Source" prop="source" class="form-item">
                            <el-select v-model="form.source" placeholder="Select source" style="width: 100%;">
                                <el-option label="ModelScope" value="modelscope"></el-option>
                                <el-option label="Hugging Face" value="huggingface"></el-option>
                            </el-select>
                        </el-form-item>
                        <el-form-item label="Model ID/URL" prop="modelId" class="form-item">
                            <el-input v-model="form.modelId" placeholder="Enter Model ID or URL"></el-input>
                            <div class="model-size-info">{{ modelSizeFeedback }}</div>
                        </el-form-item>
                        <el-form-item label="Authentication Token" prop="authToken" class="form-item">
                            <el-input type="password" v-model="form.authToken" show-password placeholder="Enter API Token"></el-input>
                        </el-form-item>
                        <el-form-item v-if="form.source === 'huggingface'" label="HF Mirror URL" prop="hfMirror" class="form-item">
                            <el-input v-model="form.hfMirror" placeholder="Enter Hugging Face Mirror URL"></el-input>
                        </el-form-item>
                        <el-form-item label="Save Path" prop="savePath" class="form-item">
                            <el-input v-model="form.savePath" placeholder="Default: ./models/[model_id]"></el-input>
                        </el-form-item>
                        
                        <!-- New Filter Section -->
                        <el-form-item label="Filter Files" prop="fileFilter" class="form-item">
                            <el-input v-model="form.fileFilter" placeholder="Regex pattern to filter files (e.g., .*\.safetensors)"></el-input>
                            <div class="filter-info">
                                Use regex patterns to filter which files to download. Examples:<br>
                                - <code>.*\.safetensors</code>: Only download safetensors files<br>
                                - <code>.*\.(bin|pt)</code>: Only download bin or pt files<br>
                                - <code>^(?!.*\.safetensors)</code>: Exclude safetensors files
                            </div>
                        </el-form-item>
                        
                        <!-- Archive After Download Section -->
                        <div class="archive-section">
                            <el-form-item label="Archive After Download" prop="archiveAfter" class="form-item">
                                <el-switch v-model="form.archiveAfter"></el-switch>
                            </el-form-item>
                            
                            <template v-if="form.archiveAfter">
                                <el-form-item label="Target Drive Path" prop="targetDrivePath" class="form-item">
                                    <el-input v-model="form.targetDrivePath" placeholder="Path to your external drive"></el-input>
                                </el-form-item>
                                <el-form-item label="Archive Name" prop="archiveName" class="form-item">
                                    <el-input v-model="form.archiveName" placeholder="e.g., my_model_archive"></el-input>
                                </el-form-item>
                                <el-form-item label="Archive Format" prop="archiveFormat" class="form-item">
                                    <el-select v-model="form.archiveFormat" placeholder="Select format" style="width: 100%;">
                                        <el-option label="ZIP" value="zip"></el-option>
                                        <el-option label="TAR" value="tar"></el-option>
                                        <el-option label="TAR.GZ" value="gztar"></el-option>
                                        <el-option label="TAR.BZ2" value="bztar"></el-option>
                                        <el-option label="TAR.XZ" value="xztar"></el-option>
                                    </el-select>
                                </el-form-item>
                                <div v-if="compressedSizeEstimate" class="model-size-info">
                                    Estimated compressed size: {{ compressedSizeEstimate }}
                                </div>
                            </template>
                        </div>
                    </el-form>

                    <div class="button-group">
                        <el-button @click="handleCheckSize" :loading="isCheckingSize">
                            Check Size
                        </el-button>
                        <el-button type="primary" @click="handleStartDownload">
                            Start Download
                        </el-button>
                    </div>

                    <div v-if="currentTask && currentTask.type === 'download'" class="progress-container">
                        <h3 class="section-title">Download Progress</h3>
                        <el-progress :percentage="currentTask.progress || 0" :stroke-width="20" :text-inside="true"></el-progress>
                        <div class="progress-text">Status: {{ currentTask.status }}</div>
                        <div class="button-group">
                            <el-button @click="handlePauseDownload">Pause</el-button>
                            <el-button @click="handleResumeDownload">Resume</el-button>
                            <el-button type="danger" @click="handleCancelDownload">Cancel</el-button>
                        </div>
                    </div>
                </el-tab-pane>

                <el-tab-pane label="Archive & Move" name="archive">
                    <h3 class="section-title">Archive Downloaded Model</h3>
                    <el-form :model="archiveForm" label-width="180px">
                        <el-form-item label="Source Folder Path" prop="sourceFolderPath" class="form-item">
                            <el-input v-model="archiveForm.sourceFolderPath" placeholder="Path to the downloaded model folder"></el-input>
                        </el-form-item>
                        <el-form-item label="Target Drive Path" prop="targetDrivePath" class="form-item">
                            <el-input v-model="archiveForm.targetDrivePath" placeholder="Path to your external drive"></el-input>
                        </el-form-item>
                        <el-form-item label="Archive Name" prop="archiveName" class="form-item">
                            <el-input v-model="archiveForm.archiveName" placeholder="e.g., my_model_archive"></el-input>
                        </el-form-item>
                        <el-form-item label="Archive Format" prop="archiveFormat" class="form-item">
                            <el-select v-model="archiveForm.archiveFormat" placeholder="Select format" style="width: 100%;">
                                <el-option label="ZIP" value="zip"></el-option>
                                <el-option label="TAR" value="tar"></el-option>
                                <el-option label="TAR.GZ" value="gztar"></el-option>
                                <el-option label="TAR.BZ2" value="bztar"></el-option>
                                <el-option label="TAR.XZ" value="xztar"></el-option>
                            </el-select>
                        </el-form-item>
                    </el-form>
                    <div class="button-group">
                        <el-button type="primary" @click="handleArchiveModel">Archive and Move</el-button>
                    </div>
                </el-tab-pane>
            </el-tabs>

            <div class="result-message" :class="globalFeedback.isError ? 'result-error' : 'result-success'" v-if="globalFeedback.message">
                {{ globalFeedback.message }}
            </div>
        </div>
        <div v-else>
            <p>Loading application components...</p>
        </div>
        <div class="debug-info" id="debug-info"></div>
    </div>

    <script>
    try {
        if (typeof Vue === 'undefined') {
            document.getElementById('debug-info').style.display = 'block';
            document.getElementById('debug-info').innerText = 'Vue.js failed to load';
        } else if (typeof ElementPlus === 'undefined') {
            document.getElementById('debug-info').style.display = 'block';
            document.getElementById('debug-info').innerText = 'ElementPlus failed to load';
        } else {
            const app = Vue.createApp({
                data() {
                    return {
                        appLoaded: true,
                        activeTab: 'download',
                        form: {
                            source: 'huggingface',
                            modelId: '',
                            authToken: '',
                            hfMirror: '',
                            savePath: '',
                            fileFilter: '',
                            archiveAfter: false,
                            targetDrivePath: '',
                            archiveName: '',
                            archiveFormat: 'zip'
                        },
                        archiveForm: {
                            sourceFolderPath: '',
                            targetDrivePath: '',
                            archiveName: '',
                            archiveFormat: 'zip'
                        },
                        modelSizeFeedback: 'Unknown (Check Size to preview)',
                        compressedSizeEstimate: '',
                        isCheckingSize: false,
                        currentTask: null,
                        progressInterval: null,
                        globalFeedback: {
                            message: '',
                            isError: false,
                            title: ''
                        },
                        backendUrl: 'http://localhost:5000/api'
                    };
                },
                mounted() {
                    this.checkBackendHealth();
                    console.log('Vue app mounted successfully');
                },
                methods: {
                    async checkBackendHealth() {
                        try {
                            const response = await axios.get(`${this.backendUrl}/health`);
                            if (response.data.status === 'ok') {
                                console.log('Backend health check passed');
                                if (!response.data.huggingface_available || !response.data.modelscope_available) {
                                    this.setGlobalFeedback('Some backend SDKs are not available. Features may be limited.', true);
                                }
                            } else {
                                this.setGlobalFeedback('Backend service is not healthy.', true);
                            }
                        } catch (error) {
                            console.error('Backend health check failed:', error);
                            this.setGlobalFeedback('Failed to connect to backend service.', true);
                        }
                    },

                    setGlobalFeedback(message, isError = false) {
                        this.globalFeedback.message = message;
                        this.globalFeedback.isError = isError;
                    },

                    resetGlobalFeedback() {
                        this.globalFeedback.message = '';
                        this.globalFeedback.isError = false;
                    },

                    async handleCheckSize() {
                        if (!this.form.modelId) {
                            this.setGlobalFeedback('Please enter a Model ID', true);
                            return;
                        }

                        this.isCheckingSize = true;
                        this.modelSizeFeedback = 'Checking size...';
                        this.resetGlobalFeedback();

                        try {
                            const response = await axios.post(`${this.backendUrl}/check-size`, {
                                source: this.form.source,
                                modelId: this.form.modelId,
                                authToken: this.form.authToken || null
                            });

                            if (response.data.status === 'success') {
                                this.modelSizeFeedback = response.data.message;
                                
                                // If we have a valid size and archive is enabled, update compressed size estimate
                                if (response.data.size_gb > 0 && this.form.archiveAfter) {
                                    // Estimate compressed size based on format
                                    let compressionRatio;
                                    switch (this.form.archiveFormat) {
                                        case 'zip':
                                            compressionRatio = 0.8; // ZIP generally gives ~20% compression
                                            break;
                                        case 'gztar':
                                            compressionRatio = 0.65; // ~35% compression
                                            break;
                                        case 'bztar':
                                            compressionRatio = 0.6; // ~40% compression
                                            break;
                                        case 'xztar':
                                            compressionRatio = 0.55; // ~45% compression
                                            break;
                                        case 'tar':
                                        default:
                                            compressionRatio = 0.95; // TAR has minimal compression
                                    }
                                    const estimatedCompressedSize = response.data.size_gb * compressionRatio;
                                    this.compressedSizeEstimate = `~${estimatedCompressedSize.toFixed(2)} GB`;
                                } else {
                                    this.compressedSizeEstimate = '';
                                }
                            } else {
                                this.modelSizeFeedback = 'Error fetching size';
                                this.setGlobalFeedback(response.data.message || 'Failed to check size', true);
                                this.compressedSizeEstimate = '';
                            }
                        } catch (error) {
                            console.error('Error checking size:', error);
                            this.modelSizeFeedback = 'Error fetching size';
                            this.setGlobalFeedback('Error connecting to backend', true);
                            this.compressedSizeEstimate = '';
                        } finally {
                            this.isCheckingSize = false;
                        }
                    },

                    async handleStartDownload() {
                        if (!this.form.modelId) {
                            this.setGlobalFeedback('Please enter a Model ID', true);
                            return;
                        }

                        // Additional validation for archive options
                        if (this.form.archiveAfter && !this.form.targetDrivePath) {
                            this.setGlobalFeedback('Please enter a target drive path for archiving', true);
                            return;
                        }

                        this.resetGlobalFeedback();
                        this.currentTask = { 
                            type: 'download', 
                            status: 'starting', 
                            progress: 0 
                        };

                        try {
                            const response = await axios.post(`${this.backendUrl}/download/start`, {
                                source: this.form.source,
                                modelId: this.form.modelId,
                                authToken: this.form.authToken || null,
                                savePath: this.form.savePath || null,
                                hfMirror: this.form.hfMirror || null,
                                fileFilter: this.form.fileFilter || null,
                                archiveAfter: this.form.archiveAfter,
                                targetDrivePath: this.form.archiveAfter ? this.form.targetDrivePath : null,
                                archiveName: this.form.archiveAfter ? this.form.archiveName : null,
                                archiveFormat: this.form.archiveAfter ? this.form.archiveFormat : null
                            });

                            if (response.data.task_id) {
                                this.currentTask = {
                                    ...this.currentTask,
                                    task_id: response.data.task_id,
                                    status: response.data.status || 'pending'
                                };
                                this.startProgressPolling(response.data.task_id);
                            } else {
                                this.setGlobalFeedback('Failed to start download', true);
                                this.currentTask = null;
                            }
                        } catch (error) {
                            console.error('Error starting download:', error);
                            this.setGlobalFeedback('Error connecting to backend', true);
                            this.currentTask = null;
                        }
                    },

                    startProgressPolling(taskId) {
                        if (this.progressInterval) clearInterval(this.progressInterval);
                        
                        this.progressInterval = setInterval(async () => {
                            try {
                                const response = await axios.get(`${this.backendUrl}/download/progress/${taskId}`);
                                this.currentTask = { ...this.currentTask, ...response.data };
                                
                                if (['completed', 'error', 'cancelled'].includes(response.data.status)) {
                                    clearInterval(this.progressInterval);
                                    if (response.data.status === 'completed') {
                                        this.setGlobalFeedback('Download completed successfully!');
                                    } else {
                                        this.setGlobalFeedback(response.data.error_message || 'Download failed', true);
                                    }
                                }
                            } catch (error) {
                                console.error('Error polling progress:', error);
                                clearInterval(this.progressInterval);
                            }
                        }, 2000);
                    },

                    handlePauseDownload() {
                        if (this.currentTask && this.currentTask.task_id) {
                            this.sendTaskCommand('pause', this.currentTask.task_id);
                        }
                    },

                    handleResumeDownload() {
                        if (this.currentTask && this.currentTask.task_id) {
                            this.sendTaskCommand('resume', this.currentTask.task_id);
                        }
                    },

                    handleCancelDownload() {
                        if (this.currentTask && this.currentTask.task_id) {
                            this.sendTaskCommand('cancel', this.currentTask.task_id);
                        }
                    },

                    async sendTaskCommand(command, taskId) {
                        try {
                            const response = await axios.post(`${this.backendUrl}/download/${command}/${taskId}`);
                            if (this.currentTask && this.currentTask.task_id === taskId) {
                                this.currentTask.status = response.data.status;
                            }
                        } catch (error) {
                            console.error(`Error sending ${command} command:`, error);
                            this.setGlobalFeedback(`Failed to ${command} download`, true);
                        }
                    },

                    async handleArchiveModel() {
                        if (!this.archiveForm.sourceFolderPath || !this.archiveForm.targetDrivePath) {
                            this.setGlobalFeedback('Source and target paths are required', true);
                            return;
                        }

                        this.resetGlobalFeedback();
                        this.currentTask = { type: 'archive', status: 'starting', progress: 0 };

                        try {
                            const response = await axios.post(`${this.backendUrl}/archive`, {
                                ...this.archiveForm
                            });
                            
                            if (response.data.task_id) {
                                this.currentTask = {
                                    ...this.currentTask,
                                    task_id: response.data.task_id,
                                    status: response.data.status || 'pending'
                                };
                                this.startProgressPolling(response.data.task_id);
                            } else {
                                this.setGlobalFeedback('Failed to start archiving', true);
                                this.currentTask = null;
                            }
                        } catch (error) {
                            console.error('Error starting archive:', error);
                            this.setGlobalFeedback('Error connecting to backend', true);
                            this.currentTask = null;
                        }
                    }
                }
            });

            app.use(ElementPlus);

            app.mount('#app');
        }
    } catch (err) {
        document.getElementById('debug-info').style.display = 'block';
        document.getElementById('debug-info').innerText = 'Error initializing app: ' + err.message;
        console.error('App initialization error:', err);
    }
    </script>
</body>
</html>